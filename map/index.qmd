---
title: Untitled
format:
  360-embed-html: default
resources:
  - style.json
  - tiles/*
  - tiles/*/*/*.pbf
  - font/*
  - font/*/*
  - testplot.png
360embed:
  before: |
    &lt;iframe allow=&quot;fullscreen&quot; allowfullscreen=&quot;true&quot; src=&quot;
  # uncomment and modify this line for production
  # url: https://may2023.360info-sinking-cities.pages.dev/news/
  url: example.com
  after: |
    &quot; title=&quot;Interactive: future heat&quot; style=&quot;width:100%; height:500px; border:none; background-color: white;&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;
---

{{< include _popup-buttons.qmd >}}

```{ojs}
//| label: libraries
//| output: false

r = require.alias({
  maplibregl: "maplibre-gl@2.4.0/dist/maplibre-gl.js",
  h3: {},
  deck: "deck.gl@8.9.4/dist.min.js",
  lumaconstants: "@luma.gl/constants@8.5.16/dist/dist.min.js"
});

maplibregl = r("maplibregl").catch(() => window["maplibregl"]);

// absolutely convulted deck.gl + luma.gl constants loading based on
// https://observablehq.com/@observablehq/how-to-require-stubborn-modules#cell-68
// (manually patching luma constants into deck's luma)
lib = {
  const deck = (window.deck = await r("deck"));
  const luma = (window.luma = await r("deck"));
  const lumaconstants = await r("lumaconstants")
  luma.GL = lumaconstants.GL;
  return {
    deck: deck,
    luma: luma
  }
}

```

```{ojs}
//| label: zoom-to-city-bounds
//| output: false

// load bounds data and extract city names
cityBounds = FileAttachment("/data/map-bounds-extent.csv").csv({ typed: true })
cityBoundsExtracted = cityBounds
  .map(d => ({ ...d, city: d.filename.split("_")[0] }))

// get bounds of selected city
// (there'll be duploicates; just grab the first)
// mapbox and deckgl take bounds in different orders, ugh
filteredCityInfo = cityBoundsExtracted.filter(d => d.city == selectedCity)
filteredCityBoundsMapbox = [
    [filteredCityInfo[0].xmin, filteredCityInfo[0].ymin],
    [filteredCityInfo[0].xmax, filteredCityInfo[0].ymax]
  ]
filteredCityBoundsDeckGL = [
  filteredCityInfo[0].xmin,
  filteredCityInfo[0].ymin,
  filteredCityInfo[0].xmax,
  filteredCityInfo[0].ymax
]

// fly to the selected city whenever it changes
map.fitBounds(filteredCityBoundsMapbox,
  {
    // easing: {
    //   // offset?
    //   duration: 1500
    // }
    linear: false
  })
```

```{ojs}
//| label: inputs
//| classes: inputForm

// get list of all unique cities (with which to populate dropdown menu below)
allCities = [...new Set(cityBoundsExtracted.map(d => d.city))]

viewof selectedCity = Inputs.select(allCities, { label: "City" });

viewof selectedCertainties = Inputs.checkbox(
  ["0to25", "25to50", "50to100", "gt100"],
  {
    label: "More or less certainty?",
    value: ["0to25", "25to50", "50to100", "gt100"]
  }
);
```

```{ojs}
//| label: raster-layer-def
//| output: false

// define layers but don't add images yet
// (also disable the default interpolation, so we can stack the layers)
layer_0to25 = new lib.deck.MapboxLayer({
  id: "raster_0to25", type: lib.deck.BitmapLayer, image: [],
  textureParameters: {
    [lib.luma.GL.TEXTURE_MIN_FILTER]: lib.luma.GL.NEAREST,
    [lib.luma.GL.TEXTURE_MAG_FILTER]: lib.luma.GL.NEAREST
  }
});
layer_25to50 = new lib.deck.MapboxLayer({
  id: "raster_25to50", type: lib.deck.BitmapLayer, image: [],
  textureParameters: {
    [lib.luma.GL.TEXTURE_MIN_FILTER]: lib.luma.GL.NEAREST,
    [lib.luma.GL.TEXTURE_MAG_FILTER]: lib.luma.GL.NEAREST
  }
});
layer_50to100 = new lib.deck.MapboxLayer({
  id: "raster_50to100", type: lib.deck.BitmapLayer, image: [],
  textureParameters: {
    [lib.luma.GL.TEXTURE_MIN_FILTER]: lib.luma.GL.NEAREST,
    [lib.luma.GL.TEXTURE_MAG_FILTER]: lib.luma.GL.NEAREST
  }
});
layer_gt100 = new lib.deck.MapboxLayer({
  id: "raster_gt100", type: lib.deck.BitmapLayer, image: [],
  textureParameters: {
    [lib.luma.GL.TEXTURE_MIN_FILTER]: lib.luma.GL.NEAREST,
    [lib.luma.GL.TEXTURE_MAG_FILTER]: lib.luma.GL.NEAREST
  }
});
```

```{ojs}
//| label: raster-layer-update
//| output: false

// conditionally display city's png if certainty is checked
path_0to25 = selectedCertainties.includes("0to25") ?
    "/data/3-pngs/" + selectedCity + "_0to25pp.png" : null
path_25to50 = selectedCertainties.includes("25to50") ?
    "/data/3-pngs/" + selectedCity + "_25to50pp.png" : null
path_50to100 = selectedCertainties.includes("50to100") ?
    "/data/3-pngs/" + selectedCity + "_50to100pp.png" : null
path_gt100 = selectedCertainties.includes("gt100") ?
    "/data/3-pngs/" + selectedCity + "_gt100pp.png" : null

// update the layers with the selected city's file paths and bounds
layer_0to25.setProps({ image: path_0to25, bounds: filteredCityBoundsDeckGL })
layer_25to50.setProps({ image: path_25to50, bounds: filteredCityBoundsDeckGL })
layer_50to100.setProps({ image: path_50to100, bounds: filteredCityBoundsDeckGL })
layer_gt100.setProps({ image: path_gt100, bounds: filteredCityBoundsDeckGL })
```

```{ojs}
//| label: map

viewof map = {
  let container = html`<div style="position: absolute; left: 0; top: 0; height: 100vh; width: 100%;" />`;

  // Give the container dimensions.
  yield container;

  // Create the \`map\` object with the mapboxgl.Map constructor, referencing
  // the container div
  let map = new maplibregl.Map({
    container,
    // bounds: [[106.282959, 11.256862], [107.143957, 10.213583]],
    bounds: [
      [-4.292916666833331, 5.22125016616666],
      [-3.7187502298333306, 5.63625000016666]
      ],
    // pitch: 30,
    antialias: true,
    style: "style.json"
  });

  // on map load:
  // - dispatch its value back to ojs
  // - add the deck.gl layers to the map
  map.on("load", () => {
    container.value = map;
    container.dispatchEvent(new CustomEvent("input"));
    
    map.addLayer(layer_0to25);
    map.addLayer(layer_25to50);
    map.addLayer(layer_50to100);
    map.addLayer(layer_gt100);
    
  });
}
```


{{< include _popup-dialogs.qmd >}}
